import * as dotenv from 'dotenv';
import { privateKeyToAccount } from 'viem/accounts';
import { createPublicClient, createWalletClient, http, getContract, parseAbiParameters, parseEther, formatEther } from 'viem';
import { sepolia } from 'viem/chains';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

dotenv.config();

// åˆ›å»ºclient
const privateKey = process.env.SEPOLIA_PRIVATE_KEY;
if (!privateKey) throw new Error('SEPOLIA_PRIVATE_KEY not found in .env');
const formattedPrivateKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;
const account = privateKeyToAccount(formattedPrivateKey as `0x${string}`);

const publicClient = createPublicClient({
  chain: sepolia,
  transport: http(process.env.SEPOLIA_RPC_URL),
});

const walletClient = createWalletClient({
  account,
  chain: sepolia,
  transport: http(process.env.SEPOLIA_RPC_URL),
});

// load deployed addresses produced by Ignition
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const deployed = JSON.parse(readFileSync(join(__dirname, '../ignition/deployments/chain-11155111/deployed_addresses.json'), 'utf8'));

// contract addresses (adjust keys per your deployed file)
const ADD = deployed;
const CUSTODIAN = ADD['coreModules#CustodianFixed'];
const LIQUIDATION = ADD['coreModules#LiquidationManager'];
const AUCTION = ADD['coreModules#AuctionManager'];
const ORACLE = ADD['coreModules#LTCPriceOracle'];
const STABLE = ADD['tokenModules#StableToken'];
const LEVERAGE = ADD['tokenModules#MultiLeverageToken'];
const WLTC = ADD['tokenModules#WLTCMock'];

if (!CUSTODIAN || !LIQUIDATION || !AUCTION || !ORACLE || !STABLE) {
  console.error('Could not find required deployed contract addresses in deployed_addresses.json');
  process.exit(1);
}

// load ABIs from artifacts generated by ignition (the project already has these files)
function loadAbi(keyPath: string) {
  try {
    const p = join(__dirname, `../ignition/deployments/chain-11155111/artifacts/${keyPath}.json`);
    const raw = JSON.parse(readFileSync(p, 'utf8'));
    return raw.abi;
  } catch (e) {
    return null;
  }
}

const custodianAbi = loadAbi('coreModules#CustodianFixed');
const liquidationAbi = loadAbi('coreModules#LiquidationManager');
const auctionAbi = loadAbi('coreModules#AuctionManager');
const oracleAbi = loadAbi('coreModules#LTCPriceOracle');
const stableAbi = loadAbi('tokenModules#StableToken');
const leverageAbi = loadAbi('tokenModules#MultiLeverageToken');
const wltcAbi = loadAbi('tokenModules#WLTCMock');

if (!custodianAbi || !liquidationAbi || !auctionAbi || !oracleAbi || !stableAbi) {
  console.error('Missing ABIs in ignition deployments folder. Ensure artifacts exist for the named keys.');
  process.exit(1);
}

const custodian = getContract({ address: CUSTODIAN as `0x${string}`, abi: custodianAbi, client: walletClient });
// merge ABIs so viem can decode custom errors that may be thrown by nested calls
const mergedForLiquidation = [
  ...(liquidationAbi || []),
  ...(custodianAbi || []),
  ...(auctionAbi || []),
  ...(leverageAbi || []),
  ...(stableAbi || []),
  ...(oracleAbi || [])
]
const liquidationManager = getContract({ address: LIQUIDATION as `0x${string}`, abi: mergedForLiquidation, client: walletClient });
const auctionManager = getContract({ address: AUCTION as `0x${string}`, abi: auctionAbi, client: walletClient });
const oracle = getContract({ address: ORACLE as `0x${string}`, abi: oracleAbi, client: walletClient });
const leverage = getContract({ address: LEVERAGE as `0x${string}`, abi: leverageAbi, client: walletClient });
const stable = getContract({ address: STABLE as `0x${string}`, abi: stableAbi, client: walletClient });
const wltc = WLTC ? getContract({ address: WLTC as `0x${string}`, abi: wltcAbi || [], client: walletClient }) : null;

async function main() {
  const me = account.address;
  console.log('Account:', me);

  // ================== 0) è½¬ç§»10ä¸‡ä¸ªstableç»™custodianï¼Œç¡®ä¿æœ‰å¥–åŠ±èµ„é‡‘ ==================
  console.log('0) ç¡®ä¿custodianFixedåˆçº¦æœ‰è¶³å¤Ÿå¥–åŠ±èµ„é‡‘...');
  const rewardAmount = 10000n * 10n ** 18n;
  let custodianStable = await stable.read.balanceOf([CUSTODIAN as `0x${string}`]) as bigint;
  if(custodianStable >= rewardAmount)console.log('âœ… Custodian already has enough stable.');
  else{
    console.log('ğŸ”¶ 0. è½¬ç§»10,000 Stableç»™ Custodian ä½œä¸ºæ¸…ç®—å¥–åŠ±èµ„é‡‘...');
    const transferTx = await stable.write.transfer([CUSTODIAN as `0x${string}`, parseEther('10000')]);
    await publicClient.waitForTransactionReceipt({ hash: transferTx });
    // console.log('âœ… Stable transferred to custodian.');
  }
  custodianStable = await stable.read.balanceOf([CUSTODIAN as `0x${string}`]) as bigint;
  console.log('Current Custodian Stable balance:', formatEther(custodianStable));
  console.log('\n');
  
  // ================== 1) find a leverage token owned by me ==================
  console.log('1) find a leverage token owned by me and choose one to liquidate...');
  const info = await custodian.read.getAllLeverageTokenInfo([me]);
  // getAllLeverageTokenInfo returns tuple arrays: tokenIds, balances,...
  const tokenIds = info[0] as bigint[];
  if (!tokenIds || tokenIds.length === 0) {
    console.error('No leverage tokens found for account. You must hold a leverage token to run this flow.');
    process.exit(1);
  }
  console.log("All leverage token id: ", info[0] as bigint[]);
  const tokenId = 2n; //æƒ³è¦æ‹å–æ¸…ç®—çš„leverage token id
  console.log('Leverage tokenId(test to liquidate):', tokenId.toString());
  // //è°ƒç”¨MultiLeverageTokençš„getTokenInfoæŸ¥çœ‹æ•°æ®
  // const tokenInfo = await leverage.read.getTokenInfo([tokenId]);
  // console.log('Leverage token info:', tokenInfo);
  
  //åˆ¤æ–­tokenIdæ˜¯å¦åœ¨tokenIdsä¸­: åŸå› 1ï¼šç”¨æˆ·æœ¬èº«æ²¡æœ‰è¯¥id; åŸå› 2ï¼šè¯¥idå·²ç»åœ¨æ¸…ç®—ä¸­ä¸å±äºç”¨æˆ·äº†
  let tokenIdUnderLiquidation = false;
  let auctionId = 0n;
  if (!tokenIds.includes(tokenId)) {
    console.error(`Cannot find the tokenid, Check whether it is under liquidation.`);
    //åˆ¤æ–­tokenIdæ˜¯å¦åœ¨æ¸…ç®—ä¸­, å› ä¸ºå¦‚æœå·²ç»å‘ç”Ÿbarkä¹‹åï¼Œç›¸åº”çš„leverage tokenå°±å·²ç»burnæ‰äº†
    let liqStatus = await liquidationManager.read.userLiquidationStatus([me, tokenId]);
    let isUnder = Boolean(
      ((liqStatus as any).isUnderLiquidation) ??
      ((liqStatus as any)[4] as boolean)
    );
    if (isUnder) {
      tokenIdUnderLiquidation = true;
      auctionId = (liqStatus as any).auctionId ?? (liqStatus as any)[7] ?? 0n;
      console.log(`Leverage token ID ${tokenId} is already under liquidation with auction ID: ${auctionId}.`);
    }
    else{ 
      console.error(`Leverage token ID ${tokenId} not owned by account. Please check the token ID.`);
      process.exit(1);
    }
  }
  console.log('\n');


  // 2) æ£€æŸ¥Oracleä»·æ ¼ï¼Œå¦‚æœæ— æ•ˆåˆ™æ›´æ–°ä¸ºä¹‹å‰çš„ä»·æ ¼
  console.log("2) æ£€æŸ¥Oracleä»·æ ¼ï¼Œå¦‚æœæ— æ•ˆåˆ™æ›´æ–°ä¸ºä¹‹å‰çš„ä»·æ ¼...");
  const oracleStatus = await oracle.read.getPriceStatus([]) as readonly [bigint, bigint, bigint, boolean, boolean, bigint];
  let currentPrice = oracleStatus[0]; // ç¬¬0ä¸ªæ˜¯currentPriceï¼Œç¬¬1ä¸ªæ˜¯lastUpdate
  const isPriceValid = oracleStatus[3];
  
  // Oracleä»·æ ¼æ˜¯18ä½å°æ•°çš„USDCä»·æ ¼ï¼Œæ˜¾ç¤ºä¸º 1 WLTC = X USDC
  console.log(`  å½“å‰ä»·æ ¼: 1 WLTC = ${formatEther(currentPrice)} USDC`);
  console.log(`  æœ‰æ•ˆæ€§: ${isPriceValid ? 'âœ… æœ‰æ•ˆ' : 'âŒ æ— æ•ˆ'}`);
  
  if (!isPriceValid) {      
      try {
        const updateTx = await oracle.write.updatePrice([currentPrice]);
        await publicClient.waitForTransactionReceipt({ hash: updateTx });
        console.log(`âœ… Oracle ä»·æ ¼å·²æ›´æ–°ä¸º: $${formatEther(currentPrice)}`);
      } catch (error: any) {
        console.error(`âŒ æ›´æ–° Oracle ä»·æ ¼å¤±è´¥:`, error.shortMessage || error.message);
        throw error;
      }
  }
  console.log('\n');


  // 3) æ£€æŸ¥æ˜¯å¦è§¦å‘æ¸…ç®—æ¡ä»¶ï¼šæœªè§¦å‘åˆ™é™ä½ oracle ä»·æ ¼(æ¯æ¬¡10%)è‡³è§¦å‘æ¸…ç®—
  if(tokenIdUnderLiquidation == false) 
  {
    //æ²¡æœ‰å¤„äºæ¸…ç®—ï¼Œåˆ™æ‰‹åŠ¨è°ƒæ•´ä»·æ ¼ï¼Œè§¦å‘bark
    //å¤„äºæ¸…ç®—ï¼Œåˆ™è·³è¿‡è¿™ä¸€æ­¥
    console.log('3) æ£€æŸ¥æ˜¯å¦è§¦å‘æ¸…ç®—æ¡ä»¶ï¼šæœªè§¦å‘åˆ™é™ä½ oracle ä»·æ ¼(æ¯æ¬¡10%)è‡³è§¦å‘æ¸…ç®—...');

    const globalConfig = await liquidationManager.read.globalConfig([]);
    const liquidationThreshold = globalConfig[1] as bigint; // per contract struct
    console.log('Liquidation threshold:', formatEther(liquidationThreshold));//è§¦å‘æ¸…ç®—é˜ˆå€¼ä¸º0.3, liquidationThresholdæœ¬èº«æ˜¯18ä½
    
    let nav: bigint;
    for(let attempt=0; attempt<10; attempt++){
      const navTuple = await custodian.read.getSingleLeverageTokenNavV2([me, tokenId]);
      nav = navTuple[2] as bigint; // net NAV in 1e18
      console.log('Current net NAV:', formatEther(nav));
      if (nav < liquidationThreshold) {
        console.log('NAV is below liquidation threshold. Ready to call bark.');
        break;
      }
      else
      {
        // updateprice to lower by 10%
        currentPrice = (currentPrice * 90n) / 100n;
        const updateTx = await oracle.write.updatePrice([currentPrice]);
        await publicClient.waitForTransactionReceipt({ hash: updateTx });
        console.log(`âœ… Oracle ä»·æ ¼å·²æ›´æ–°ä¸º: $${formatEther(currentPrice)}`);
      } 
    }
    console.log('\n');

    // let tokenId = 8n; //æƒ³è¦æ‹å–æ¸…ç®—çš„leverage token id
    // let auctionId = 0n;
    // 4) æ£€æŸ¥æ˜¯å¦barkè¿‡ï¼Œæ²¡æœ‰åˆ™è°ƒç”¨barkè§¦å‘æ¸…ç®—æ‹å–
    console.log('4) æ£€æŸ¥æ˜¯å¦barkè¿‡ï¼Œæ²¡æœ‰åˆ™è°ƒç”¨barkè§¦å‘æ¸…ç®—æ‹å–...');
    let liqStatus = await liquidationManager.read.userLiquidationStatus([me, tokenId]);
    let isUnder = Boolean(
      ((liqStatus as any).isUnderLiquidation) ??
      ((liqStatus as any)[4] as boolean)
    );

    console.log('isUnderLiquidation:', isUnder);
    if (isUnder) {
      console.log('âŒ è´¦æˆ·å·²è§¦å‘æ¸…ç®—ï¼Œè¯·å‹¿é‡å¤æ“ä½œ');
      auctionId = (liqStatus as any).auctionId ?? (liqStatus as any)[7] ?? 0n;
      console.log(`Leverage token ID ${tokenId} is already under liquidation with auction ID: ${auctionId}.`);

    }
    else {
      console.log('âœ… è´¦æˆ·æœªè§¦å‘æ¸…ç®—ï¼Œå‡†å¤‡bark...');
      try {
        const barkTx = await liquidationManager.write.bark([me, tokenId, me]);//åœ¨barkä¸­å·²ç»burnæ‰ç›¸åº”çš„leverage tokenäº†
        const receipt = await publicClient.waitForTransactionReceipt({ hash: barkTx });
        console.log('âœ… Bark completed, liquidation triggered.');
        liqStatus = await liquidationManager.read.userLiquidationStatus([me, tokenId]);
        auctionId = (liqStatus as any).auctionId ?? (liqStatus as any)[7] ?? 0n;
        console.log(`Leverage token ID ${tokenId} is already under liquidation with auction ID: ${auctionId}.`);
          } catch (e: any) {
            console.error('bark failed:', e?.message ?? e);
            process.exit(1);
        }
    }
    tokenIdUnderLiquidation = true;
    console.log('\n');
  }

  console.log('5) æ£€æŸ¥æ˜¯å¦éœ€è¦resetAuctionï¼Œéœ€è¦çš„è¯åˆ™reset...');
  if(!tokenIdUnderLiquidation || auctionId === 0n){
    console.error('Leverage token is not under liquidation or auctionId is invalid. Exiting.');
    process.exit(1);
  }
  else
  {
    let statusArr = await auctionManager.read.getAuctionStatus([BigInt(auctionId)]);
    // const currentAuctionPrice = statusArr[1] as bigint;
    // console.log('Current auction price:', formatEther(currentAuctionPrice));
    const needtoReset = statusArr[0] as boolean;
    if (needtoReset) {
      console.log('Auction is not valid anymore, resetting auction...');
      try {
        const resetTx = await auctionManager.write.resetAuction([BigInt(auctionId),me]);
        console.log('reset tx hash:', resetTx);
        await publicClient.waitForTransactionReceipt({ hash: resetTx });
        console.log('Auction reset completed');
      } catch (e: any) {
        console.error('resetAuction failed:', e?.message ?? e);
        process.exit(1);
      }
    }
  }
  console.log('\n');


  console.log('6) bidder approve stable to custodian for auction purchase, then purchase...');
  const auctionInfo = await auctionManager.read.auctions([BigInt(auctionId)]);
  const underlying = auctionInfo[1] as bigint;
  console.log('Auction underlying amount:', formatEther(underlying));
  const approveAmount = 1000000n * 10n ** 18n;
  try {
    console.log('Approving Stable token to custodian for auction purchase...');
    const apTx = await stable.write.approve([CUSTODIAN as `0x${string}`, approveAmount]);
    await publicClient.waitForTransactionReceipt({ hash: apTx });
    console.log('Stable approved');
  } catch (e: any) {
    console.error('approve failed:', e?.message ?? e);
    // process.exit(1);
  }
  const purchaseAmount = underlying;
  try {
    console.log('Purchasing underlying via auctionManager.purchaseUnderlying...');
    const purchaseTx = await auctionManager.write.purchaseUnderlying([BigInt(auctionId), purchaseAmount, currentPrice, me, '0x']);
    console.log('purchase tx hash:', purchaseTx);
    await publicClient.waitForTransactionReceipt({ hash: purchaseTx });
    console.log('Purchase completed');
  } catch (e: any) {
    console.error('purchaseUnderlying failed:', e?.message ?? e);
    process.exit(1);
  }
  console.log('\n');
  
  console.log('7) å°è¯• withdrawStable æå–æ¸…ç®—æ‰€å¾—...');
  try {
    console.log('Attempting withdrawStable as liquidated user...');
    const withdrawTx = await liquidationManager.write.withdrawStable([me, tokenId]);
    console.log('withdraw tx hash:', withdrawTx);
    await publicClient.waitForTransactionReceipt({ hash: withdrawTx });
    console.log('Withdraw completed');
  } catch (e: any) {
    console.error('withdrawStable failed (maybe not ready):', e?.message ?? e);
  }
  console.log('\n');

  console.log('8) Final liquidation status check...');
  const finalStatus = await liquidationManager.read.userLiquidationStatus([me, tokenId]);
  console.log('Final liquidation status:', finalStatus);


  console.log('Done');
}

main().catch((e) => { console.error('Script failed:', e); process.exit(1); });
